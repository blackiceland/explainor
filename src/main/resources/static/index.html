<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Explainor - Stage 2 Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        #container { display: flex; width: 90%; max-width: 1800px; gap: 20px; }
        #controls { flex: 1; display: flex; flex-direction: column; }
        #canvas-wrapper { flex: 2; }
        textarea { width: 100%; height: 400px; font-family: monospace; font-size: 12px; }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
        }
        button:hover { background: #2563EB; }
        #canvas {
            position: relative;
            width: 1280px;
            height: 720px;
            background-color: #D1D5DB;
            overflow: hidden;
            transform-origin: top left;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        .node {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
        }
    </style>
</head>
<body>

<h1>Explainor - Stage 2: "The Rock"</h1>
<div id="container">
    <div id="controls">
        <h3>1. Storyboard Input</h3>
        <textarea id="storyboard-input"></textarea>
        <br>
        <button id="submit-btn">Choreograph</button>
        <div id="error-output" style="color: #EF4444; margin-top: 10px; font-weight: 500;"></div>
    </div>
    <div id="canvas-wrapper">
        <h3>2. Rendered Timeline Output</h3>
        <div id="canvas"></div>
    </div>
</div>

<script>
    const sampleStoryboard = {
        "version": "1.0.0",
        "commands": [
            { "type": "create_entity", "id": "user", "params": { "label": "User" } },
            { "type": "create_entity", "id": "auth_service", "params": { "label": "Auth Service" } },
            { "type": "create_entity", "id": "user_db", "params": { "label": "User DB" } },
            { "type": "create_entity", "id": "api_gateway", "params": { "label": "API Gateway" } },
            { "type": "create_entity", "id": "order_service", "params": { "label": "Order Service" } },
            { "type": "create_entity", "id": "order_db", "params": { "label": "Order DB" } },
            { "type": "connect_entities", "id": "conn1", "params": { "from": "user", "to": "api_gateway", "label": "1. Login Request" } },
            { "type": "connect_entities", "id": "conn2", "params": { "from": "api_gateway", "to": "auth_service", "label": "2. Validate Credentials" } },
            { "type": "connect_entities", "id": "conn3", "params": { "from": "auth_service", "to": "user_db", "label": "3. Fetch User" } },
            { "type": "connect_entities", "id": "conn4", "params": { "from": "user", "to": "api_gateway", "label": "4. Create Order" } },
            { "type": "connect_entities", "id": "conn5", "params": { "from": "api_gateway", "to": "order_service", "label": "5. Process Order" } },
            { "type": "connect_entities", "id": "conn6", "params": { "from": "order_service", "to": "order_db", "label": "6. Save Order" } }
        ]
    };

    document.getElementById('storyboard-input').value = JSON.stringify(sampleStoryboard, null, 2);

    document.getElementById('submit-btn').addEventListener('click', async () => {
        const storyboardJson = document.getElementById('storyboard-input').value;
        const canvas = document.getElementById('canvas');
        const errorOutput = document.getElementById('error-output');
        canvas.innerHTML = '';
        errorOutput.textContent = '';

        try {
            const response = await fetch('/api/genesis/choreograph', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: storyboardJson
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`[${response.status}] ${errorData.error}: ${errorData.message}`);
            }

            const timeline = await response.json();
            renderTimeline(timeline, canvas);

        } catch (err) {
            console.error(err);
            errorOutput.textContent = `Error: ${err.message}`;
        }
    });

    function renderTimeline(timeline, canvas) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', timeline.stage.width);
        svg.setAttribute('height', timeline.stage.height);
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';

        // Render edges first (background layer)
        timeline.edges.forEach(edge => {
            const style = edge.edgeStyle;
            const pathData = edge.path.map((p, i) => (i === 0 ? 'M' : 'L') + `${p.x} ${p.y}`).join(' ');
            
            // Main edge line
            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', pathData);
            pathEl.setAttribute('fill', 'none');
            pathEl.setAttribute('stroke', style.strokeColor);
            pathEl.setAttribute('stroke-width', style.strokeWidth);
            pathEl.setAttribute('filter', 'drop-shadow(0px 2px 4px rgba(0, 0, 0, 0.15))');
            svg.appendChild(pathEl);
            
            // Arrow at the end
            if (edge.path.length >= 2) {
                const last = edge.path[edge.path.length - 1];
                const preLast = edge.path[edge.path.length - 2];
                const angle = Math.atan2(last.y - preLast.y, last.x - preLast.x);
                const arrowSize = 10;
                
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const x1 = last.x - arrowSize * Math.cos(angle - Math.PI / 6);
                const y1 = last.y - arrowSize * Math.sin(angle - Math.PI / 6);
                const x2 = last.x - arrowSize * Math.cos(angle + Math.PI / 6);
                const y2 = last.y - arrowSize * Math.sin(angle + Math.PI / 6);
                arrow.setAttribute('points', `${last.x},${last.y} ${x1},${y1} ${x2},${y2}`);
                arrow.setAttribute('fill', style.strokeColor);
                svg.appendChild(arrow);
            }
            
            // Edge label
            if (edge.label && edge.path.length > 1) {
                const midPointIndex = Math.floor(edge.path.length / 2);
                const midPoint = edge.path[midPointIndex];
                const labelStyle = style.labelStyle;
                
                // Label background
                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.textContent = edge.label;
                textEl.setAttribute('font-family', labelStyle.textStyle.fontFamily);
                textEl.setAttribute('font-size', labelStyle.textStyle.fontSize);
                textEl.setAttribute('font-weight', labelStyle.textStyle.fontWeight);
                textEl.setAttribute('fill', labelStyle.textStyle.color);
                svg.appendChild(textEl);
                
                const bbox = textEl.getBBox();
                const bgWidth = bbox.width + labelStyle.paddingX * 2;
                const bgHeight = bbox.height + labelStyle.paddingY * 2;
                
                labelBg.setAttribute('x', midPoint.x - bgWidth / 2);
                labelBg.setAttribute('y', midPoint.y - bgHeight / 2);
                labelBg.setAttribute('width', bgWidth);
                labelBg.setAttribute('height', bgHeight);
                labelBg.setAttribute('rx', labelStyle.borderRadius);
                labelBg.setAttribute('fill', labelStyle.backgroundColor);
                labelBg.setAttribute('filter', 'drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.1))');
                svg.insertBefore(labelBg, textEl);
                
                textEl.setAttribute('x', midPoint.x);
                textEl.setAttribute('y', midPoint.y + bbox.height / 3);
                textEl.setAttribute('text-anchor', 'middle');
            }
        });

        canvas.appendChild(svg);

        // Render nodes (foreground layer)
        timeline.nodes.forEach(node => {
            const style = node.visualStyle;
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            nodeEl.style.width = `${style.width}px`;
            nodeEl.style.height = `${style.height}px`;
            nodeEl.style.backgroundColor = style.backgroundColor;
            nodeEl.style.border = `${style.borderWidth}px solid ${style.borderColor}`;
            nodeEl.style.borderRadius = `${style.borderRadius}px`;
            nodeEl.style.fontFamily = style.textStyle.fontFamily;
            nodeEl.style.fontSize = `${style.textStyle.fontSize}px`;
            nodeEl.style.fontWeight = style.textStyle.fontWeight;
            nodeEl.style.color = style.textStyle.color;
            
            // Multi-layered shadow
            nodeEl.style.boxShadow = `
                0px 4px 8px rgba(0, 0, 0, 0.1),
                0px 10px 20px rgba(0, 0, 0, 0.15)
            `;
            
            nodeEl.textContent = node.label;
            canvas.appendChild(nodeEl);
        });
    }
</script>

</body>
</html>
